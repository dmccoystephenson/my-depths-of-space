{"version":3,"file":"tactics.js","mappings":"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","sources":["webpack://tactics/webpack/universalModuleDefinition","webpack://tactics/webpack/bootstrap","webpack://tactics/webpack/runtime/define property getters","webpack://tactics/webpack/runtime/hasOwnProperty shorthand","webpack://tactics/webpack/runtime/make namespace object","webpack://tactics/./src/images.js","webpack://tactics/./src/mainScene.js","webpack://tactics/./src/input.js","webpack://tactics/./src/menuScene.js","webpack://tactics/./src/grammar.js","webpack://tactics/./src/main.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tactics\"] = factory();\n\telse\n\t\troot[\"tactics\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import images from './images.json'\r\n\r\nvar ctx = null\r\n\r\nfunction setContext(context) {\r\n    ctx = context\r\n}\r\n\r\nfunction getContext() {\r\n    return ctx\r\n}\r\n\r\nfunction getImage(name) {\r\n    let img = images.filter(f => f.name === name)\r\n    return img.length > 0 ? img[0].image : null\r\n}\r\n\r\nfunction getImages() {\r\n    return images\r\n}\r\n\r\nfunction drawImage(name, x, y, srcRect) {\r\n    let img = images.filter(f => f.name === name)\r\n    if (img.length > 0) {\r\n        if (srcRect) {\r\n            ctx.drawImage(img[0].image, srcRect.x, srcRect.y, srcRect.w, srcRect.h, x, y, srcRect.w, srcRect.h)\r\n        } else {\r\n            ctx.drawImage(img[0].image, x, y)\r\n        }\r\n    }\r\n}\r\n\r\nfunction loadImage(filename) {\r\n    return new Promise((resolve, reject) => {\r\n        let img = new Image()\r\n        img.onload = (e) => {\r\n            resolve(img)\r\n        }\r\n        img.onerror = (e) => {\r\n            console.error(`Failed to load file ${filename}:`, e)\r\n            reject(null)\r\n        }\r\n        let image = images.filter(f => f.filename === filename)\r\n        if (image.length > 0) {\r\n            img.src = filename\r\n        } else {\r\n            console.error(`Image definition matching filename ${filename} not found.`)\r\n            reject(null)\r\n        }\r\n    })\r\n}\r\n\r\nfunction loadAllImages() {\r\n    let promises = []\r\n    for (let i in images) {\r\n        let image = images[i]\r\n        promises.push(new Promise((resolve, reject) => loadImage(image.filename).then(r => {\r\n            image.image = r\r\n            resolve(r)\r\n        }).catch(e => console.error('Failed to load', image.filename, e))))\r\n    }\r\n    return Promise.allSettled(promises)\r\n}\r\n\r\nexport { loadAllImages, loadImage, drawImage, getImage, getImages, setContext, getContext }\r\n","import { getContext } from \"./images.js\"\r\n\r\nlet imu = null\r\n\r\nlet ctx = null\r\n\r\nvar selectedAttack = 0\r\nvar tooltip = ''\r\n\r\nfunction getSelectedAttack() {\r\n    return selectedAttack\r\n}\r\n\r\nfunction incrementSelectedAttack(amt) {\r\n    selectedAttack += (amt !== undefined ? amt : 1)\r\n    if (selectedAttack > 2) {\r\n        selectedAttack = 0\r\n    } else if (selectedAttack < 0) {\r\n        selectedAttack = 2\r\n    }\r\n    Player().selectedWeapon = selectedAttack\r\n    return selectedAttack\r\n}\r\n\r\nfunction drawFrame(delta) {\r\n    if (!ctx) {\r\n        ctx = getContext()\r\n    }\r\n    ctx.clearRect(0, 0, 240, 160)\r\n\r\n    ctx.save()\r\n    ctx.translate(120 - Player().x * TileSizes().x, 80 - Player().y * TileSizes().y)\r\n    DrawFOV(Player())\r\n    Player().draw()\r\n    let spriteObjs = getSpriteObjects()\r\n    for (let index in spriteObjs) {\r\n        spriteObjs[index].update(16)\r\n        spriteObjs[index].draw()\r\n    }\r\n\r\n    ctx.restore()\r\n\r\n    drawUI()\r\n}\r\n\r\nfunction drawUI(delta) {\r\n    if (!imu) {\r\n        imu = new imui.ImUI(ctx.canvas)\r\n        imu.font = font\r\n\r\n        imu.onUpdate = (ui) => {\r\n            if (getTargets().length > 0) {\r\n                let targetPct = getSelectedTarget().hp / getSelectedTarget().maxhp\r\n                let targetHealth = 'It is in perfect health.' + getSelectedTarget().state\r\n                if (targetPct < 0.05) {\r\n                    targetHealth = 'It is near death.'\r\n                } else if (targetPct < 0.3) {\r\n                    targetHealth = 'It is gravely injured.'\r\n                } else if (targetPct < 0.6) {\r\n                    targetHealth = 'It is hurt.'\r\n                } else if (targetPct < 0.85) {\r\n                    targetHealth = 'It is bruised.'\r\n                } else if (targetPct < 1) {\r\n                    targetHealth = 'It is scratched.'\r\n                }\r\n                switch(selectedAttack) {\r\n                    case 0:\r\n                        tooltip = `Melee attack against ${getSelectedTarget().name}.\\n${targetHealth}`\r\n                        break\r\n                    case 1:\r\n                        tooltip = `Ranged attack against ${getSelectedTarget().name}.\\n${targetHealth}`\r\n                        break\r\n                    case 2:\r\n                        tooltip = `Area attack against ${getSelectedTarget().name}.\\n${targetHealth}`\r\n                        break;    \r\n                }    \r\n            } else {\r\n                let calcDmg = CalculateDamage(Player(), selectedAttack)\r\n                switch(selectedAttack) {\r\n                    case 0:\r\n                        tooltip = `Melee attack (${Player().slots[0]}/16 shards)\\nMin/Avg/Max: ${calcDmg.min.toFixed(2)}/${calcDmg.avg.toFixed(2)}/${calcDmg.max.toFixed(2)}`\r\n                        break\r\n                    case 1:\r\n                        tooltip = `Ranged attack (${Player().slots[1]}/16 shards)\\nMin/Avg/Max: ${calcDmg.min.toFixed(2)}/${calcDmg.avg.toFixed(2)}/${calcDmg.max.toFixed(2)}`\r\n                        break\r\n                    case 2:\r\n                        tooltip = `Area attack (${Player().slots[2]}/16 shards)\\nMin/Avg/Max: ${calcDmg.min.toFixed(2)}/${calcDmg.avg.toFixed(2)}/${calcDmg.max.toFixed(2)}`\r\n                        break;    \r\n                }    \r\n            }\r\n\r\n            ui.RemoveElement('tooltip')\r\n            ui.Element({ id: 'lblGamename', text: `Grimoire`, rect: { x: 2, y: 0, w: 64, h: 8 }, color: '#c10000ff', highlight: '#c10000ff', bgcolor: '#cccccc00', font: nightmare })\r\n\r\n            ui.Element({ id: 'lblScore', text: `Score: ${Player().score}`, rect: { x: 108, y: 5, w: 64, h: 8 }, color: '#f1f1f1ff', highlight: '#f1f1f1ff', bgcolor: '#cccccc00' })\r\n            ui.Element({ id: 'lblXp', text: `XP: ${Player().xp}`, rect: { x: 172, y: 5, w: 64, h: 8 }, color: '#f1f1f1ff', highlight: '#f1f1f1ff', bgcolor: '#cccccc00' })\r\n\r\n            ui.Element({ id: 'lblHp', text: `HP: ${Player().hp}/${Player().maxhp}`, rect: { x: 108, y: 15, w: 64, h: 8 }, color: '#f1f1f1ff', highlight: '#f1f1f1ff', bgcolor: '#cccccc00' })\r\n\r\n            ui.Element({ id: 'lblMelee', text: `${selectedAttack === 0 ? '>': ' '} Melee ${parseInt(Player().slots[0] / 16 * 100)}%`, rect: { x: 0, y: 136, w: 64, h: 8 }, color: '#f1f1f1ff', highlight: '#f1f1f1ff', bgcolor: '#cccccc00' })\r\n            ui.Element({ id: 'lblRanged', text: `${selectedAttack === 1 ? '>' : ' '} Ranged ${parseInt(Player().slots[1] / 16 * 100)}%`, rect: { x: 0, y: 144, w: 64, h: 8 }, color: '#f1f1f1ff', highlight: '#f1f1f1ff', bgcolor: '#cccccc00' })\r\n            ui.Element({ id: 'lblArea', text: `${selectedAttack === 2 ? '>' : ' '} Area ${parseInt(Player().slots[2] / 16 * 100)}%`, rect: { x: 0, y: 152, w: 64, h: 8 }, color: '#f1f1f1ff', highlight: '#f1f1f1ff', bgcolor: '#cccccc00' })\r\n\r\n            if (tooltip.length > 0) {\r\n                ui.Element({ id: 'tooltip', text: tooltip + `\\n${Player().x}, ${Player().y}`, rect: { x: 66, y: 136, w: 194, h: 24 }, wrap: 'word', color: '#f1f1f1ff', highlight: '#f1f1f1ff', bgcolor: '#cccccc00' })\r\n            }\r\n        }\r\n    }\r\n    imu.Draw()\r\n}\r\n\r\nexport { drawFrame, getSelectedAttack, incrementSelectedAttack }","import maps from './keymapping.json'\r\n\r\nvar listening = false\r\n\r\nfunction handlerPressed (button) {\r\n  setState(button, true)\r\n}\r\n\r\nfunction handlerReleased (button) {\r\n  setState(button, false)\r\n  if (callbacks[button]) {\r\n    callbacks[button](button)\r\n  }\r\n}\r\n\r\nfunction GetInputKeys(inputType) {\r\n  inputType = inputType.toLowerCase()\r\n  return Object.keys(maps[inputType])\r\n}\r\n\r\nfunction GetInputValue(inputType, key) {\r\n  inputType = inputType.toLowerCase()\r\n  return maps[inputType][key]\r\n}\r\n\r\nvar inputState = {}\r\nvar callbacks = {}\r\n\r\nvar enabled = [ 'keyboard', 'gamepad' ]\r\n\r\nfunction setState(button, value) {\r\n  inputState[button] = value\r\n}\r\n\r\nfunction getState(button) {\r\n  if (!listening) {\r\n    return false\r\n  }\r\n  return inputState[button] ? inputState[button] : false\r\n}\r\n\r\nfunction listenerKeyDown(e) {\r\n  if (!listening) {\r\n    return\r\n  }\r\n  let inputs = Object.keys(maps.keyboard)\r\n  for (let i in inputs) {\r\n    if (e.key === maps.keyboard[inputs[i]]) {\r\n      handlerPressed(inputs[i])\r\n    }\r\n  }\r\n}\r\n\r\nfunction listenerKeyUp(e) {\r\n  if (!listening) {\r\n    return\r\n  }\r\n  console.log(e)\r\n  let inputs = Object.keys(maps.keyboard)\r\n  for (let i in inputs) {\r\n    if (e.key === maps.keyboard[inputs[i]]) {\r\n      handlerReleased(inputs[i])\r\n    }\r\n  }\r\n}\r\n\r\nfunction init() {\r\n  inputState = {}\r\n  callbacks = {}\r\n  if (enabled.includes('keyboard')) {\r\n    window.removeEventListener('keydown', listenerKeyDown)\r\n    window.removeEventListener('keyup', listenerKeyUp)\r\n    window.addEventListener('keydown', listenerKeyDown)\r\n    window.addEventListener(\"keyup\", listenerKeyUp)\r\n  }\r\n  if (enabled.includes('gamepad')) {\r\n    gameControl.on('connect', function(gamepad) {\r\n      let inputs = Object.keys(maps.gamepad)\r\n      for (let i in inputs) {\r\n        gamepad.on(maps.gamepad[inputs[i]], () => {\r\n          \r\n        }).after(maps.gamepad[inputs[i]], () => {\r\n          handlerReleased(inputs[i])\r\n        })\r\n      }\r\n    })\r\n  }\r\n  listening = false\r\n}\r\n\r\ninit()\r\n\r\nvar input = {\r\n  listen: () => {\r\n    listening = true\r\n  },\r\n  unlisten: () => {\r\n    listening = false\r\n  },\r\n  released: (button, method) => {\r\n    callbacks[button] = method\r\n  }\r\n}\r\n\r\nexport default input\r\nexport { GetInputKeys, GetInputValue }","import input, { GetInputKeys, GetInputValue } from './input.js'\r\nimport { getContext, drawImage, getImage } from \"./images.js\"\r\nimport { Start } from './main.js'\r\n\r\nlet imu = null\r\n\r\nlet ctx = null\r\n\r\nvar menuItems = []\r\nvar menuSelect = ''\r\nvar selectedInput = 'gamepad'\r\nvar startingShards = 5\r\nvar rangedAmt = 0\r\nvar areaAmt = 0\r\nvar meleeAmt = 0\r\n\r\nlet menuDx = 0\r\nlet menuDy = 0\r\n\r\nfunction drawFrame(delta) {\r\n    if (!ctx) {\r\n        ctx = getContext()\r\n    }\r\n    ctx.clearRect(0, 0, 240, 160)\r\n\r\n    drawUI()\r\n}\r\n\r\nfunction SetMenu(id) {\r\n    if (id === 'Settings') {\r\n        menuItems = [\r\n            { text: 'Difficulty', value: 'Easy', action: (menuItem) => { menuItem.value = menuItem.value === 'Easy' ? 'Hard' : 'Easy' } },\r\n            { text: 'Controls', value: '', action: (menuItem) => { SetMenu('Controls') } },\r\n            { text: 'Back', value: '', action: (menuItem) => { SetMenu() } }\r\n        ]\r\n        menuSelect = 'Difficulty'\r\n        menuDx = 70\r\n        menuDy = 60\r\n    } else if (id === 'Controls') {\r\n        menuItems = [\r\n            { text: 'Input Type', value: selectedInput.slice(0, 1).toUpperCase() + selectedInput.slice(1), action: (menuItem) => {\r\n                selectedInput = menuItem.value.toLowerCase() === 'gamepad' ? 'Keyboard' : 'Gamepad'\r\n                SetMenu(id)\r\n                return\r\n            }}\r\n        ]\r\n        let inputs = GetInputKeys(selectedInput)\r\n        for (let i in inputs) {\r\n            console.log(inputs[i], GetInputValue(selectedInput, inputs[i]))\r\n            menuItems.push({\r\n                text: inputs[i], value: GetInputValue(selectedInput, inputs[i]), action: (menuItem) => { console.log('listen for keypress') }\r\n            })\r\n        }\r\n        menuItems.push({ text: 'Back', value: '', action: () => { SetMenu('Settings') }})\r\n        menuSelect = 'Input Type'\r\n        menuDx = 70\r\n        menuDy = 20\r\n    } else if (id === 'Character') {\r\n        menuItems = [\r\n            { text: `Soul Shards: ${startingShards}`, value: '', action: (menuItem) => {} },\r\n            { text: '+1 Melee', value: meleeAmt.toString(), action: (menuItem) => {\r\n                if (startingShards > 0) {\r\n                    startingShards--\r\n                    meleeAmt++\r\n                    SetMenu('Character')\r\n                }\r\n            } },\r\n            { text: '+1 Ranged', value: rangedAmt.toString(), action: (menuItem) => {\r\n                if (startingShards > 0) {\r\n                    startingShards--\r\n                    rangedAmt++\r\n                    SetMenu('Character')\r\n                }\r\n            } },\r\n            { text: '+1 Area', value: areaAmt.toString(), action: (menuItem) => {\r\n                if (startingShards > 0) {\r\n                    startingShards--\r\n                    areaAmt++\r\n                    SetMenu('Character')\r\n                }\r\n            } },\r\n            { text: 'Begin', value: '', action: () => Start(meleeAmt, rangedAmt, areaAmt)}\r\n        ]\r\n        if (menuItems.findIndex(f => f.text === menuSelect) < 0) {\r\n            menuSelect = `+1 Melee`\r\n        }\r\n    } else {\r\n        menuItems = [\r\n            { text: 'Start', value: '', action: (menuItem) => { SetMenu('Character') } },\r\n            { text: 'Settings', value: '', action: (menuItem) => { SetMenu('Settings')} },\r\n            { text: 'Credits', value: '', action: (menuItem) => {} }\r\n        ]\r\n        menuSelect = 'Start'\r\n        menuDx = 90\r\n        menuDy = 40\r\n    }\r\n}\r\n\r\nfunction moveMenu(y) {\r\n    let index = menuItems.findIndex(f => f.text === menuSelect)\r\n    index += y\r\n    if (index > menuItems.length - 1) {\r\n        index = 0\r\n    } else if (index < 0) {\r\n        index = menuItems.length - 1\r\n    }\r\n    menuSelect = menuItems[index].text\r\n}\r\n\r\nfunction SelectedMenuItem() {\r\n    return menuItems.filter(f => f.text === menuSelect)[0]\r\n}\r\n\r\nfunction handleEvent() {\r\n    \r\n    input.listen()\r\n\r\n    input.released('moveUp', (button) => {\r\n        moveMenu(-1)\r\n    })\r\n\r\n    input.released('moveDown', (button) => {\r\n        moveMenu(1)\r\n    })\r\n\r\n    input.released('attack', (button) => {\r\n        SelectedMenuItem().action(SelectedMenuItem())\r\n    })\r\n\r\n}\r\n\r\nfunction drawUI(delta) {\r\n    if (!imu) {\r\n        imu = new imui.ImUI(ctx.canvas)\r\n        imu.font = font\r\n\r\n        imu.onUpdate = (ui) => {\r\n            //ui.Element({ id: 'imgGamename', type: 'Image', x: 10, y: 10, image: getImage('title') })\r\n\r\n            let dy = menuDy + 30\r\n            for (let i in menuItems) {\r\n                let item = menuItems[i].text\r\n                let value = ''\r\n                if (menuItems[i].value.length > 0) {\r\n                    value = menuItems[i].value\r\n                }\r\n                ui.Element({ id: 'lblMenu' + item, text: `${menuSelect === item ? '>' : ' '}${item}${menuSelect === item ? '<' : ' ' }${value.length > 0 ? `     ${value}` : ''}`, rect: { x: menuDx, y: dy, w: 64, h: 8 }, color: '#f1f1f1ff', highlight: '#f1f1f1ff', bgcolor: '#cccccc00' })\r\n                dy += 12\r\n            }\r\n        }\r\n    }\r\n    imu.Draw()\r\n    drawImage('title', 120 - 52, 10)\r\n}\r\n\r\nexport { drawFrame, handleEvent, SetMenu }","let grammar = {}\r\n\r\nfunction randInt(min, max) {\r\n    return Math.floor(ROT.RNG.getUniform() * (max - min + 1) + min)\r\n  }\r\n\r\nfunction roll(dice) {\r\n    dice = dice.toLowerCase();\r\n    if (!dice.includes('d')) {\r\n        throw new Error('At least one term must specify the number of dice.')\r\n    } else {\r\n        let dieterm = dice.split('d')\r\n        let amt = 0\r\n        for (let times = 0; times < dieterm[0]; times++) {\r\n            amt += randInt(1, dieterm[1])\r\n        }\r\n        return amt\r\n    }\r\n}\r\n\r\n/**\r\n * The value for the key specified as the id parameter. Value is either an array of strings or a string reference to an array of strings.\r\n * @param {string} id \r\n * @returns {string|array} Returns either the value of the key matching 'id', or an empty string.\r\n */\r\nfunction get(id) {\r\n    if (!id) {\r\n        return ''\r\n    }\r\n    if (typeof id === 'string') {\r\n        id = id.replace('[*', '').replace(']', '')\r\n    }\r\n    let item = grammar[id]\r\n    if (item) {\r\n        if (typeof item === 'string') {\r\n            return item\r\n        } else if (typeof item === 'object') {\r\n            return item[randInt(0, item.length - 1)]\r\n        }\r\n    }\r\n    return id //`[not found:${id}]`\r\n}\r\n\r\n/**\r\n * Set the value for the key specified as the id parameter. Value is either an array of strings or a string reference to an array of strings.\r\n * @param {string} id \r\n * @param {string|array} value \r\n */\r\nfunction set(id, value) {\r\n    grammar[id] = value\r\n}\r\n\r\n/**\r\n * Processes any operators on the text about to be added to the sentence chain.\r\n * @param {string} txt \r\n * @param {string} operator \r\n * @returns \r\n */\r\nfunction operatorText(txt, operator) {\r\n    if (operator === 'capital') {\r\n        txt = txt.charAt(0).toUpperCase() + txt.slice(1)\r\n    }\r\n    return txt\r\n}\r\n\r\nfunction parseTokens(template, context) {\r\n    if (template.includes('[')) {\r\n        let startPos = 0\r\n        let tokenMap = []\r\n        while(template.includes('[', startPos)) {\r\n            let paramStart = template.indexOf('[', startPos)\r\n            if (paramStart > startPos) {\r\n                tokenMap.push({ start: startPos, end: paramStart, token: null, value: template.substring(startPos, paramStart) })    \r\n            }\r\n            let paramEnd = template.indexOf(']', startPos)\r\n            let token = template.substring(paramStart, paramEnd + 1)\r\n            tokenMap.push({ start: paramStart, end: paramEnd, token: token, value: null })\r\n            startPos = paramEnd + 1\r\n        }\r\n        if (startPos < template.length) {\r\n            tokenMap.push({ start: startPos, end: template.length - 1, token: null, value: template.substring(startPos, template.length)})\r\n        }\r\n        return tokenMap\r\n    } else {\r\n        return [template]\r\n    }\r\n}\r\n\r\nfunction compareOperation(property, operation, operator, value) {\r\n    if (operation === \"is\") {\r\n        if (operator === '=') {\r\n            return property === value\r\n        }\r\n    } else if (operation === \"has\") {\r\n        if (operator === \"=\") {\r\n            return property[value] !== undefined\r\n        }\r\n    } else {\r\n        if (typeof property === 'object' && [\"=\", \"!=\", \">=\", \"<=\", \"<\", \">\"].includes(operator)) {\r\n            if ([\"=\", \"!=\"].includes(operator)) {\r\n                return operator === \"=\" ? property[operation] === value : property[operation] !== value\r\n            } else if ([\">=\", \"<=\"].includes(operator)) {\r\n                return operator === \">=\" ? property[operation] >= value : property[operation] <= value\r\n            } else if ([\">\", \"<\"].includes(operator)) {\r\n                return operator === \">\" ? property[operation] > value : property[operation] < value\r\n            }            \r\n        } else if (typeof property === 'number' && [\"=\", \"!=\", \">=\", \"<=\", \"<\", \">\"].includes(operator)) {\r\n            if ([\"=\", \"!=\"].includes(operator)) {\r\n                return operator === \"=\" ? property === value : property !== value\r\n            } else if ([\">=\", \"<=\"].includes(operator)) {\r\n                return operator === \">=\" ? property >= value : property <= value\r\n            } else if ([\">\", \"<\"].includes(operator)) {\r\n                return operator === \">\" ? property > value : property < value\r\n            }            \r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nfunction process(template, context) {\r\n    if (!template.includes('[')) {\r\n        return {\r\n            'tokenmap': {},\r\n            'sentence': template,\r\n            'sentenceHTML': template\r\n        }\r\n    }\r\n    context = context ? context : {}\r\n    let tokenMap = processTokenMap(parseTokens(template, context), context)\r\n    let sentence = ''\r\n    let sentenceHTML = ''\r\n    let map = tokenMap\r\n    for (let m in map) {\r\n        if (m > 0) {\r\n            let prev = map[m - 1]\r\n            if ((prev.token_type === 'condition' && prev.token_result) || (prev.token_type !== 'condition' && map[m].value)) {\r\n                if (map[m].token) {\r\n                    prev.value = map[m].value\r\n                    sentenceHTML += `<mark title='${m > 0 ? JSON.stringify(prev) : map[m].token}'>${map[m].value}</mark>`\r\n                    sentence += map[m].value\r\n                } else {\r\n                    sentenceHTML += map[m].value\r\n                    sentence += map[m].value\r\n                }\r\n            }\r\n        } else {\r\n            if (map[m].token && map[m].value) {\r\n                sentenceHTML += `<mark title='${map[m].token}'>${map[m].value}</mark>`\r\n                sentence += map[m].value\r\n            } else if (map[m].value) {\r\n                    sentenceHTML += map[m].value\r\n                    sentence += map[m].value\r\n            }\r\n        }\r\n    }\r\n    if (!sentence.includes('[')) {\r\n        return {\r\n            'tokenmap': tokenMap,\r\n            'sentence': sentence,\r\n            'sentenceHTML': sentenceHTML\r\n        }\r\n    } else {\r\n        return process(sentence, context)\r\n    }\r\n}\r\n\r\nfunction processTokenMap(tokenMap, context) {\r\n    let activeConditional = -1\r\n    for (let t in tokenMap) {\r\n        if (tokenMap[t].value === null) {\r\n            if (tokenMap[t].token) {\r\n                if (tokenMap[t].token.substring(0, 2) === '[*') {\r\n                    tokenMap[t].token_type = 'lookup'\r\n                    let id = tokenMap[t].token.substring(2, tokenMap[t].token.length - 1)\r\n                    if (!id.includes('[')) {\r\n                        tokenMap[t].value = get(id)\r\n                    }\r\n                } else if (tokenMap[t].token.substring(0, 2) === '[?') {\r\n                    tokenMap[t].token_type = 'condition'\r\n                    activeConditional = t\r\n                    let id = tokenMap[t].token.substring(2, tokenMap[t].token.length - 1)\r\n                    let paths = id.split('.')\r\n\r\n                    let room = null\r\n                    if (context.room) {\r\n                        room = rooms.getRoom(context.room)\r\n                    }\r\n\r\n                    if (paths.length === 3) {\r\n                        let contextName = paths[0]\r\n                        let contextProperty = paths[1]\r\n                        let comparison = paths[2]\r\n\r\n                        if (contextName === 'room' && room) {\r\n                            if (room[contextProperty]) {\r\n                                let comp = comparison.search(/[(=)(!=)(<)(>)(>=)(<=)]/)\r\n                                if (comp >= 0) {\r\n                                    let operation = comparison.substring(0, comp)\r\n                                    let opEnd = comparison.slice(comp).search(/[A-Za-z0-9_-]/)\r\n                                    if (opEnd < 0) {\r\n                                        opEnd = 1\r\n                                    }\r\n                                    let operator = comparison.substring(comp, comp + opEnd)\r\n                                    let value = comparison.substring(comp + 1, comparison.length)\r\n                                    tokenMap[t].token_operation = operation\r\n                                    tokenMap[t].token_operator = operator\r\n                                    tokenMap[t].token_compare_to = value\r\n                                    tokenMap[t].token_property = room[contextProperty]\r\n                                    tokenMap[t].token_result = compareOperation(room[contextProperty], operation, operator, value)\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (paths.length === 1) {\r\n                        // If there's no path, try a die roll notation.\r\n                        let comparison = paths[0]\r\n                        let comp = comparison.search(/[(=)(!=)(<)(>)(>=)(<=)]/)\r\n                        if (comp >= 0) {\r\n                            let operation = comparison.substring(0, comp)\r\n                            let opEnd = comparison.slice(comp).search(/[A-Za-z0-9_-]/)\r\n                            if (opEnd < 0) {\r\n                                opEnd = 1\r\n                            }\r\n                            let operator = comparison.substring(comp, comp + opEnd)\r\n                            let value = parseInt(comparison.substring(comp + 1, comparison.length))\r\n                            let rl = roll(operation)\r\n                            tokenMap[t].die_roll = rl\r\n                            tokenMap[t].token_operation = operation\r\n                            tokenMap[t].token_operator = operator\r\n                            tokenMap[t].token_compare_to = value\r\n                            tokenMap[t].token_property = rl\r\n                            tokenMap[t].token_result = compareOperation(rl, operation, operator, value)\r\n                        }\r\n                    }\r\n                } else if (tokenMap[t].token.toLowerCase() === \"[else]\") {\r\n                    if (activeConditional >= 0) {\r\n                        tokenMap[t].token_operation = tokenMap[activeConditional].token_operation\r\n                        tokenMap[t].token_operator = tokenMap[activeConditional].token_operator\r\n                        tokenMap[t].token_compare_to = tokenMap[activeConditional].token_compare_to\r\n                        tokenMap[t].token_property = tokenMap[activeConditional].token_property\r\n                        tokenMap[t].token_type = 'condition'\r\n                        tokenMap[t].token_result = !compareOperation(tokenMap[t].token_property, tokenMap[t].token_operation, tokenMap[t].token_operator, tokenMap[t].token_compare_to)\r\n                        activeConditional = -1\r\n                    }\r\n                } else if (tokenMap[t].token.substring(0, 1) === '[') {\r\n                    tokenMap[t].value = tokenMap[t].token.replace('[', '').replace(']', '')\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return tokenMap\r\n}\r\n\r\n/**\r\n * Get the generated text of the specified template text.\r\n * @param {string} template Template text to generate from the dictionary.\r\n * @param {object} context JSON containing the list of contexts and their objects to execute under.\r\n * @returns {string} Evaluated text result.\r\n */\r\nfunction text(template, context) {\r\n    let sentence = []\r\n    let startPos = 0\r\n    // If there are any tokens to process in this template.\r\n    if (template.includes('[')) {\r\n        let paramStart = 0\r\n        let paramEnd = template.indexOf('[')\r\n        while(template.includes('[', startPos)) {\r\n            paramStart = template.indexOf('[', startPos)\r\n            paramEnd = template.indexOf(']', startPos)\r\n            //sentence.push(template.substring(startPos, paramStart))\r\n            let id = template.substring(paramStart, paramEnd + 1)\r\n            \r\n            let operator\r\n            if (id.includes('.')) {\r\n                let parts = id.split('.')\r\n                id = parts[0] + ']'\r\n                operator = parts[1].toLowerCase().substring(0, parts[1].length - 1)\r\n            }\r\n            if (id !== template) {\r\n                let txt = text(id)\r\n                sentence.push(txt)\r\n            } else {\r\n                let txt = get(id)\r\n                sentence.push(txt)\r\n            }\r\n            startPos = paramEnd + 1\r\n        }\r\n        if (startPos < template.length) {\r\n            sentence.push(template.substring(startPos, template.length))\r\n        }\r\n    } else {\r\n        let id = get(template)\r\n        return id ? id : `[not found:${id}]` \r\n    }\r\n\r\n    let ret = sentence.reduce((prev, next) => prev + next)\r\n    return ret.includes('[*') ? text(ret) : ret\r\n}\r\n\r\n/**\r\n * Sets the whole dictionary object to the json parameter.\r\n * @param {object} json \r\n */\r\nfunction setDictionary(json) {\r\n    grammar = json\r\n}\r\n\r\n/**\r\n * Loads the dictionary from a file buffer.\r\n * @param {buffer} buffer \r\n */\r\nfunction loadDictionary(buffer) {\r\n    grammar = JSON.parse(buffer.toString())\r\n}\r\n\r\nexport { loadDictionary, setDictionary, text, set, get, roll, randInt }","import images from './images.js'\r\nimport sfx from './sfx.js'\r\nimport music from './music.js'\r\nimport sprites from './sprites.js'\r\nimport { setContext, loadAllImages } from './images.js'\r\nimport { drawFrame as drawMain } from './mainScene.js'\r\nimport { drawFrame as drawMainMenu, handleEvent, SetMenu } from './menuScene.js'\r\nimport { set, setDictionary } from './grammar.js'\r\nimport input from './input.js'\r\n\r\nvar dateNow = Date.now()\r\nvar dateThen = Date.now()\r\n\r\nvar targetDelta = 16 // Roughly 60fps by default\r\n\r\nvar currentScene = 'mainMenu'\r\n\r\nfunction setTargetFrameRate(target) {\r\n    targetDelta = parseInt(1000 / target) // Number of ms divided by target fps\r\n}\r\n\r\nfunction requestAnimationFrame() {\r\n    dateNow = Date.now()\r\n    let delta = dateNow - dateThen\r\n    if (delta >= targetDelta) {\r\n        drawFrame(delta)\r\n        dateThen = dateNow\r\n    }\r\n    window.requestAnimationFrame(requestAnimationFrame)\r\n}\r\n\r\n/**\r\n * Draws the animation frame.\r\n * @param {number} delta Number of ms since last frame.\r\n */\r\nfunction drawFrame(delta) {\r\n    if (currentScene === 'mainMenu') {\r\n        drawMainMenu(delta)\r\n    } else if (currentScene === 'main') {\r\n        drawMain(delta)\r\n    }\r\n}\r\n\r\nasync function StartMainMenu() {\r\n    await loadAllImages()\r\n\r\n    let canvas = document.getElementById('maincanvas')\r\n    let ratio = canvas.width / canvas.height\r\n    canvas.style.height = window.innerHeight + 'px'\r\n    canvas.style.width = window.innerHeight * ratio + 'px'\r\n    window.addEventListener('resize', () => {\r\n        canvas.style.height = window.innerHeight + 'px'\r\n        canvas.style.width = window.innerHeight * ratio + 'px'\r\n      })\r\n\r\n    SetMenu()\r\n\r\n    setTargetFrameRate(60)\r\n    setContext(canvas.getContext('2d'))\r\n\r\n    handleEvent()\r\n\r\n    window.requestAnimationFrame(requestAnimationFrame)\r\n}\r\n\r\nasync function Start(melee, ranged, area) {\r\n\r\n    input.unlisten()\r\n\r\n    setDictionary(bestiary.dictionary)\r\n    LoadCombatBonusTable()\r\n\r\n    set('dirt_floors', ['floor', 'floor_dirt'])\r\n    set('grimoire', grimoire)\r\n\r\n    let digger = await Digger(30, 30)\r\n    \r\n    Init(CreatePlayer('@', digger.Floors()))\r\n    Player().slots = [melee, ranged, area]\r\n    AddTemples(3)\r\n    currentScene = 'main'\r\n}\r\n\r\nexport { Start, StartMainMenu }"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ctx","getContext","imu","selectedAttack","tooltip","listening","handlerReleased","button","setState","callbacks","GetInputValue","inputType","toLowerCase","inputState","enabled","listenerKeyDown","e","inputs","keys","i","listenerKeyUp","console","log","includes","window","removeEventListener","addEventListener","gameControl","on","gamepad","after","listen","unlisten","released","method","menuItems","menuSelect","selectedInput","startingShards","rangedAmt","areaAmt","meleeAmt","menuDx","menuDy","SetMenu","id","text","action","menuItem","slice","toUpperCase","push","toString","Start","findIndex","f","moveMenu","y","index","length","SelectedMenuItem","filter","grammar","set","dateNow","Date","now","dateThen","targetDelta","currentScene","requestAnimationFrame","clearRect","imui","ImUI","canvas","font","onUpdate","ui","dy","item","Element","rect","x","w","h","color","highlight","bgcolor","Draw","name","srcRect","img","drawImage","image","delta","save","translate","Player","TileSizes","DrawFOV","draw","spriteObjs","getSpriteObjects","update","restore","getTargets","targetPct","getSelectedTarget","hp","maxhp","targetHealth","state","calcDmg","CalculateDamage","slots","min","toFixed","avg","max","RemoveElement","nightmare","score","xp","parseInt","wrap","async","StartMainMenu","promises","Promise","resolve","reject","loadImage","filename","Image","onload","onerror","error","src","then","r","catch","allSettled","loadAllImages","document","getElementById","ratio","width","height","context","style","innerHeight","melee","ranged","area","json","bestiary","dictionary","LoadCombatBonusTable","grimoire","digger","Digger","Init","CreatePlayer","Floors","AddTemples"],"sourceRoot":""}